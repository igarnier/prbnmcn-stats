<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Rational (prbnmcn-stats.Stats__Fin.Rational)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">prbnmcn-stats</a> &#x00BB; <a href="../index.html">Stats__Fin</a> &#x00BB; Rational</nav><h1>Module <code>Stats__Fin.Rational</code></h1><p><code>Q</code>-valued finitely supported distributions.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Stats/Stats_intf/index.html#module-type-Fin_dist">Stats.Stats_intf.Fin_dist</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../Stats/Stats_intf/module-type-Fin_dist/index.html#type-r">r</a> = Q.t</code></span></summary><dl><dt class="spec type" id="type-r"><a href="#type-r" class="anchor"></a><code><span class="keyword">type</span> r</code><code> = Q.t</code></dt><dt class="spec type" id="type-finfn"><a href="#type-finfn" class="anchor"></a><code><span class="keyword">type</span> <span>'a finfn</span></code><code> = <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_fun">Stats.Stats_intf.fin_fun</a></span></code></dt><dd><p>The type of finite functions with domain <code>'a</code> and range <code>r</code>.</p></dd></dl><dl><dt class="spec type" id="type-prb"><a href="#type-prb" class="anchor"></a><code><span class="keyword">type</span> <span>'a prb</span></code><code> = <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span></code></dt><dd><p>The type of finite probability measures with domain <code>'a</code> and range <code>r</code>.</p></dd></dl><dl><dt class="spec type" id="type-mes"><a href="#type-mes" class="anchor"></a><code><span class="keyword">type</span> <span>'a mes</span></code><code> = <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span></code></dt><dd><p>The type of finite measures with domain <code>'a</code> and range <code>r</code>.</p></dd></dl><aside><p>Constructing measures and probabilities</p></aside><dl><dt class="spec value" id="val-measure"><a href="#val-measure" class="anchor"></a><code><span class="keyword">val</span> measure : <span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Free_module_std <span class="keyword">with</span> <span class="keyword">type</span> Basis.t = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> R.t = <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span> * <a href="index.html#type-r">r</a>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span></code></dt><dd><p>Creates a finitely supported <em>measure</em> from weighted points. A measure is not necessarily normalized. The underlying set needs to be totally ordered.</p><dl><dt>raises Invalid_argument</dt><dd><p>if a weight is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-probability"><a href="#val-probability" class="anchor"></a><code><span class="keyword">val</span> probability : <span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Free_module_std <span class="keyword">with</span> <span class="keyword">type</span> Basis.t = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> R.t = <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span> * <a href="index.html#type-r">r</a>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span></code></dt><dd><p>Creates a finitely supported _probability_ from weighted points. A probability is normalized. The underlying set needs to be totally ordered.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the sum of the weights is not equal to one or if a weight is negative.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-kernel"><a href="#val-kernel" class="anchor"></a><code><span class="keyword">val</span> kernel : <span>?&#8288;h:<span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Std <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Free_module_std <span class="keyword">with</span> <span class="keyword">type</span> Basis.t = <span class="type-var">'b</span> <span class="keyword">and</span> <span class="keyword">type</span> R.t = <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span> * <a href="index.html#type-r">r</a>)</span> list</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span></code></dt><dd><p>Creates a _kernel_. Needs not be normalized.</p></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">val</span> compose : <span>?&#8288;h:<span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Std <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span></code></dt><dd><p>Kernel composition.</p></dd></dl><dl><dt class="spec value" id="val-pushforward"><a href="#val-pushforward" class="anchor"></a><code><span class="keyword">val</span> pushforward : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'u</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'u</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span></code></dt><dd><p>Computes the pushforward of a finitely supported measure along a kernel.</p></dd></dl><dl><dt class="spec value" id="val-inverse"><a href="#val-inverse" class="anchor"></a><code><span class="keyword">val</span> inverse : <span>?&#8288;h:<span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Std <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'u</span>)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <span class="type-var">'u</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'u</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span> * <span><span>(<span class="type-var">'u</span>, <span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span></code></dt><dd><p>Bayesian inverse of a kernel. Defined up to a null set wrt the pushforward of the prior. Assumes that the kernel is <em>probability</em>-valued.</p></dd></dl><dl><dt class="spec value" id="val-constant_kernel"><a href="#val-constant_kernel" class="anchor"></a><code><span class="keyword">val</span> constant_kernel : <span><span>(<span class="type-var">'b</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span></code></dt><dd><p>Constant kernel.</p></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span></code></dt><dd><p>Normalize a measure to obtain a probability measure.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the measure has zero mass.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-counts_of_empirical"><a href="#val-counts_of_empirical" class="anchor"></a><code><span class="keyword">val</span> counts_of_empirical : <span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Free_module_std <span class="keyword">with</span> <span class="keyword">type</span> Basis.t = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> R.t = <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'t</span> array</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span></code></dt><dd><p>Computes the empirical measure of an array of elements. Each element present in the array is mapped to its count.</p></dd></dl><dl><dt class="spec value" id="val-uniform"><a href="#val-uniform" class="anchor"></a><code><span class="keyword">val</span> uniform : <span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Free_module_std <span class="keyword">with</span> <span class="keyword">type</span> Basis.t = <span class="type-var">'t</span> <span class="keyword">and</span> <span class="keyword">type</span> R.t = <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'t</span> array</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span></code></dt><dd><p>Finitely supported uniform distribution.</p></dd></dl><dl><dt class="spec value" id="val-coin"><a href="#val-coin" class="anchor"></a><code><span class="keyword">val</span> coin : <span>bias:<a href="index.html#type-r">r</a></span> <span>&#45;&gt;</span> <span><span>(bool, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span></code></dt><dd><p>Biased coin. Raises an error if <code>bias</code> is not in <code>0,1</code>.</p></dd></dl><dl><dt class="spec value" id="val-binomial"><a href="#val-binomial" class="anchor"></a><code><span class="keyword">val</span> binomial : <span><span>(bool, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span>(int, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span></code></dt><dd><p>Binomial distribution. <code>binomial p n</code> returns the probability of having <code>k</code> successes over <code>n</code> experiments, according to a biased coin <code>p</code>.</p></dd></dl><aside><p>Using measures and probabilities</p></aside><dl><dt class="spec value" id="val-integrate"><a href="#val-integrate" class="anchor"></a><code><span class="keyword">val</span> integrate : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a></code></dt><dd><p>Integrates a function against a finitely supported measure.</p></dd></dl><dl><dt class="spec value" id="val-eval_prb"><a href="#val-eval_prb" class="anchor"></a><code><span class="keyword">val</span> eval_prb : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span> <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a></code></dt><dd><p>Evaluates a finitely supported probability on argument. Returns 0 if the argument is out of the support.</p></dd></dl><dl><dt class="spec value" id="val-eval_mes"><a href="#val-eval_mes" class="anchor"></a><code><span class="keyword">val</span> eval_mes : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span class="type-var">'t</span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a></code></dt><dd><p>Evaluates a finitely supported measure on argument. Returns 0 if the argument is out of the support.</p></dd></dl><dl><dt class="spec value" id="val-eval_kernel"><a href="#val-eval_kernel" class="anchor"></a><code><span class="keyword">val</span> eval_kernel : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-kernel">Stats.Stats_intf.kernel</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span> * <a href="index.html#type-r">r</a>)</span> list</span></code></dt><dd><p>Evaluate a kernel at a point, yielding a finitely supported measure.</p></dd></dl><dl><dt class="spec value" id="val-sample"><a href="#val-sample" class="anchor"></a><code><span class="keyword">val</span> sample : <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../Stats/Stats_intf/index.html#type-gen">Stats.Stats_intf.gen</a></span></code></dt><dd><p>Samples from a finitely supported distribution presented as an unnormalized measure. This is mostly useful when sampling only once or twice from a distribution: consider converting to a categorical sampler when sampling repeatedly. Complexity: O(n) with <code>n</code> the cardinality of the support.</p></dd></dl><dl><dt class="spec value" id="val-total_mass"><a href="#val-total_mass" class="anchor"></a><code><span class="keyword">val</span> total_mass : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a></code></dt><dd><p>Returns the total mass associated to a finitely supported measure.</p></dd></dl><dl><dt class="spec value" id="val-mean_generic"><a href="#val-mean_generic" class="anchor"></a><code><span class="keyword">val</span> mean_generic : <span>(<span class="keyword">module</span> Basic_structures.Basic_intf.Module <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'elt</span> <span class="keyword">and</span> <span class="keyword">type</span> R.t = <a href="index.html#type-r">r</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'elt</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span class="type-var">'elt</span></code></dt><dd><p>Compute the mean of a finite measure supported on an <code>Intf.Module</code>.</p></dd></dl><dl><dt class="spec value" id="val-mean"><a href="#val-mean" class="anchor"></a><code><span class="keyword">val</span> mean : <span><span>(<a href="index.html#type-r">r</a>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a></code></dt><dd><p>Compute the mean of a finite measure supported by r.</p></dd></dl><dl><dt class="spec value" id="val-variance"><a href="#val-variance" class="anchor"></a><code><span class="keyword">val</span> variance : <span><span>(<a href="index.html#type-r">r</a>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a></code></dt><dd><p>Compute the variance of a finite measure supported by r.</p></dd></dl><dl><dt class="spec value" id="val-raw_data_measure"><a href="#val-raw_data_measure" class="anchor"></a><code><span class="keyword">val</span> raw_data_measure : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> <span>[&gt; <span>`Measure of <span><span>(<span class="type-var">'t</span> * <a href="index.html#type-r">r</a>)</span> list</span></span> ]</span></code></dt><dd><p>Returns the raw data underlying a finitely supported measure.</p></dd></dl><dl><dt class="spec value" id="val-raw_data_probability"><a href="#val-raw_data_probability" class="anchor"></a><code><span class="keyword">val</span> raw_data_probability : <span><span>(<span class="type-var">'t</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_prb">Stats.Stats_intf.fin_prb</a></span> <span>&#45;&gt;</span> <span>[&gt; <span>`Probability of <span><span>(<span class="type-var">'t</span> * <a href="index.html#type-r">r</a>)</span> list</span></span> ]</span></code></dt><dd><p>Returns the raw data underlying a finitely supported probability.</p></dd></dl><dl><dt class="spec value" id="val-pp_fin_mes"><a href="#val-pp_fin_mes" class="anchor"></a><code><span class="keyword">val</span> pp_fin_mes : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty print a measure, with elements sorted according to the order relation on the support.</p></dd></dl><dl><dt class="spec value" id="val-pp_fin_mes_by_measure"><a href="#val-pp_fin_mes_by_measure" class="anchor"></a><code><span class="keyword">val</span> pp_fin_mes_by_measure : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-r">r</a>)</span> <a href="../../Stats/Stats_intf/index.html#type-fin_mes">Stats.Stats_intf.fin_mes</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty print a measure, with elements sorted by increasing measure..</p></dd></dl><dl><dt class="spec value" id="val-fold_union"><a href="#val-fold_union" class="anchor"></a><code><span class="keyword">val</span> fold_union : <span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'t</span> <a href="index.html#type-mes">mes</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'t</span> <a href="index.html#type-mes">mes</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold over the union of the supports of the given measures.</p></dd></dl></details></div></div></div><div class="spec module" id="module-Dist"><a href="#module-Dist" class="anchor"></a><code><span class="keyword">module</span> <a href="Dist/index.html">Dist</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>